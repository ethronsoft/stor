<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STOR: esft::stor::node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">STOR
   </div>
   <div id="projectbrief">Server-less, Embeddable NoSQL Document Store</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>esft</b></li><li class="navelem"><b>stor</b></li><li class="navelem"><a class="el" href="classesft_1_1stor_1_1node.html">node</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classesft_1_1stor_1_1node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">esft::stor::node Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>node represents an interface to a specific element in the underlying JSON data tree.  
 <a href="classesft_1_1stor_1_1node.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="node_8h_source.html">node.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for esft::stor::node:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classesft_1_1stor_1_1node.png" usemap="#esft::stor::node_map" alt=""/>
  <map id="esft::stor::node_map" name="esft::stor::node_map">
<area href="classesft_1_1stor_1_1document.html" title="Document is a Node that represnts the root of the node&#39;s tree. " alt="esft::stor::document" shape="rect" coords="0,56,119,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae2b2e10cc72986dba0d9d57ac6892a67"><td class="memItemLeft" align="right" valign="top"><a id="ae2b2e10cc72986dba0d9d57ac6892a67"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#ae2b2e10cc72986dba0d9d57ac6892a67">~node</a> ()</td></tr>
<tr class="memdesc:ae2b2e10cc72986dba0d9d57ac6892a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:ae2b2e10cc72986dba0d9d57ac6892a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438cf98554f0e666dc9d161dbf4f9a4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a438cf98554f0e666dc9d161dbf4f9a4f">node</a> (const <a class="el" href="classesft_1_1stor_1_1node.html">node</a> &amp;o)</td></tr>
<tr class="memdesc:a438cf98554f0e666dc9d161dbf4f9a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shallow Copy constructor.  <a href="#a438cf98554f0e666dc9d161dbf4f9a4f">More...</a><br /></td></tr>
<tr class="separator:a438cf98554f0e666dc9d161dbf4f9a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378002bd8fe1e1e99b4c52b893bdc9f8"><td class="memItemLeft" align="right" valign="top"><a id="a378002bd8fe1e1e99b4c52b893bdc9f8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a378002bd8fe1e1e99b4c52b893bdc9f8">node</a> (<a class="el" href="classesft_1_1stor_1_1node.html">node</a> &amp;&amp;o)</td></tr>
<tr class="memdesc:a378002bd8fe1e1e99b4c52b893bdc9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a378002bd8fe1e1e99b4c52b893bdc9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7868f607e839511f8520dce6c2727773"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classesft_1_1stor_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a7868f607e839511f8520dce6c2727773">operator=</a> (const <a class="el" href="classesft_1_1stor_1_1node.html">node</a> &amp;o)</td></tr>
<tr class="memdesc:a7868f607e839511f8520dce6c2727773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shallow Copy assignment.  <a href="#a7868f607e839511f8520dce6c2727773">More...</a><br /></td></tr>
<tr class="separator:a7868f607e839511f8520dce6c2727773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23531350d8f34870343e4ede042e390a"><td class="memItemLeft" align="right" valign="top"><a id="a23531350d8f34870343e4ede042e390a"></a>
<a class="el" href="classesft_1_1stor_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a23531350d8f34870343e4ede042e390a">operator=</a> (<a class="el" href="classesft_1_1stor_1_1node.html">node</a> &amp;&amp;o)</td></tr>
<tr class="memdesc:a23531350d8f34870343e4ede042e390a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment. <br /></td></tr>
<tr class="separator:a23531350d8f34870343e4ede042e390a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536b1db2509af69b76b02f9ea3fba20f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a536b1db2509af69b76b02f9ea3fba20f">is_num</a> () const</td></tr>
<tr class="memdesc:a536b1db2509af69b76b02f9ea3fba20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether underlying data is a Number.  <a href="#a536b1db2509af69b76b02f9ea3fba20f">More...</a><br /></td></tr>
<tr class="separator:a536b1db2509af69b76b02f9ea3fba20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f9e757796834aea042a285ad8cc403"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#ad6f9e757796834aea042a285ad8cc403">is_int</a> () const</td></tr>
<tr class="memdesc:ad6f9e757796834aea042a285ad8cc403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether underlying data is a Integer.  <a href="#ad6f9e757796834aea042a285ad8cc403">More...</a><br /></td></tr>
<tr class="separator:ad6f9e757796834aea042a285ad8cc403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27119b0e30639a436f51efafbbfdf293"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a27119b0e30639a436f51efafbbfdf293">is_bool</a> () const</td></tr>
<tr class="memdesc:a27119b0e30639a436f51efafbbfdf293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether underlying data is a Boolean.  <a href="#a27119b0e30639a436f51efafbbfdf293">More...</a><br /></td></tr>
<tr class="separator:a27119b0e30639a436f51efafbbfdf293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8c9e74cf4eca77c747e03ac9a0714d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#ade8c9e74cf4eca77c747e03ac9a0714d">is_long</a> () const</td></tr>
<tr class="memdesc:ade8c9e74cf4eca77c747e03ac9a0714d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether underlying data is a Long.  <a href="#ade8c9e74cf4eca77c747e03ac9a0714d">More...</a><br /></td></tr>
<tr class="separator:ade8c9e74cf4eca77c747e03ac9a0714d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24be3f8c6ba5c5f998366ecc2eca25a6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a24be3f8c6ba5c5f998366ecc2eca25a6">is_double</a> () const</td></tr>
<tr class="memdesc:a24be3f8c6ba5c5f998366ecc2eca25a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether underlying data is a Double.  <a href="#a24be3f8c6ba5c5f998366ecc2eca25a6">More...</a><br /></td></tr>
<tr class="separator:a24be3f8c6ba5c5f998366ecc2eca25a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c1d002e2042fd0bf984d34a3069a5d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#ac1c1d002e2042fd0bf984d34a3069a5d">is_string</a> () const</td></tr>
<tr class="memdesc:ac1c1d002e2042fd0bf984d34a3069a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether underlying data is a String.  <a href="#ac1c1d002e2042fd0bf984d34a3069a5d">More...</a><br /></td></tr>
<tr class="separator:ac1c1d002e2042fd0bf984d34a3069a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9542d872fcdc42b454a550625f6c9316"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a9542d872fcdc42b454a550625f6c9316">is_object</a> () const</td></tr>
<tr class="memdesc:a9542d872fcdc42b454a550625f6c9316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether underlying data is an Object.  <a href="#a9542d872fcdc42b454a550625f6c9316">More...</a><br /></td></tr>
<tr class="separator:a9542d872fcdc42b454a550625f6c9316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0255e81d5c5062cfb59b39f3850ff5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#adf0255e81d5c5062cfb59b39f3850ff5">is_array</a> () const</td></tr>
<tr class="memdesc:adf0255e81d5c5062cfb59b39f3850ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether underlying data is an Array.  <a href="#adf0255e81d5c5062cfb59b39f3850ff5">More...</a><br /></td></tr>
<tr class="separator:adf0255e81d5c5062cfb59b39f3850ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe91d9d1f0fee459a05ddb3296cd1eb8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#afe91d9d1f0fee459a05ddb3296cd1eb8">is_null</a> () const</td></tr>
<tr class="memdesc:afe91d9d1f0fee459a05ddb3296cd1eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether underlying data is Null.  <a href="#afe91d9d1f0fee459a05ddb3296cd1eb8">More...</a><br /></td></tr>
<tr class="separator:afe91d9d1f0fee459a05ddb3296cd1eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d772245bf170ac691daf82dcbe34e1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a56d772245bf170ac691daf82dcbe34e1">as_int</a> () const</td></tr>
<tr class="memdesc:a56d772245bf170ac691daf82dcbe34e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to return the underlying data as Integer.  <a href="#a56d772245bf170ac691daf82dcbe34e1">More...</a><br /></td></tr>
<tr class="separator:a56d772245bf170ac691daf82dcbe34e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1c34d6c6f449b57600c9ddbacd0622"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a1e1c34d6c6f449b57600c9ddbacd0622">as_long</a> () const</td></tr>
<tr class="memdesc:a1e1c34d6c6f449b57600c9ddbacd0622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to return the underlying data as Long.  <a href="#a1e1c34d6c6f449b57600c9ddbacd0622">More...</a><br /></td></tr>
<tr class="separator:a1e1c34d6c6f449b57600c9ddbacd0622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d18ca9a9123367d5f602c82d11e24c"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a42d18ca9a9123367d5f602c82d11e24c">as_double</a> () const</td></tr>
<tr class="memdesc:a42d18ca9a9123367d5f602c82d11e24c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to return the underlying data as Double.  <a href="#a42d18ca9a9123367d5f602c82d11e24c">More...</a><br /></td></tr>
<tr class="separator:a42d18ca9a9123367d5f602c82d11e24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275c4efee89c3b60e7665440e9efe52b"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a275c4efee89c3b60e7665440e9efe52b">as_string</a> () const</td></tr>
<tr class="memdesc:a275c4efee89c3b60e7665440e9efe52b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to return the underlying data as a string.  <a href="#a275c4efee89c3b60e7665440e9efe52b">More...</a><br /></td></tr>
<tr class="separator:a275c4efee89c3b60e7665440e9efe52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e0b75292eb7e044277d0df69801e9f"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; const char *, std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a30e0b75292eb7e044277d0df69801e9f">as_cstring</a> () const</td></tr>
<tr class="memdesc:a30e0b75292eb7e044277d0df69801e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to return the underlying data as a C string paired with its actual length.  <a href="#a30e0b75292eb7e044277d0df69801e9f">More...</a><br /></td></tr>
<tr class="separator:a30e0b75292eb7e044277d0df69801e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68336ff0acdeb2b1aad7c14ca4c1171"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#ab68336ff0acdeb2b1aad7c14ca4c1171">as_bool</a> () const</td></tr>
<tr class="memdesc:ab68336ff0acdeb2b1aad7c14ca4c1171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to return the underlying data as Boolean.  <a href="#ab68336ff0acdeb2b1aad7c14ca4c1171">More...</a><br /></td></tr>
<tr class="separator:ab68336ff0acdeb2b1aad7c14ca4c1171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346697a0fe0f1f8d37b704e406711e8c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a346697a0fe0f1f8d37b704e406711e8c">with</a> (const std::string &amp;key)</td></tr>
<tr class="memdesc:a346697a0fe0f1f8d37b704e406711e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get or create in place object node under key.  <a href="#a346697a0fe0f1f8d37b704e406711e8c">More...</a><br /></td></tr>
<tr class="separator:a346697a0fe0f1f8d37b704e406711e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14da3cd4ff8ca9fd8d3f393e9ceb3aca"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a14da3cd4ff8ca9fd8d3f393e9ceb3aca">with_array</a> (const std::string &amp;key)</td></tr>
<tr class="memdesc:a14da3cd4ff8ca9fd8d3f393e9ceb3aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get or create in place array node under key.  <a href="#a14da3cd4ff8ca9fd8d3f393e9ceb3aca">More...</a><br /></td></tr>
<tr class="separator:a14da3cd4ff8ca9fd8d3f393e9ceb3aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208863ad493da732d40e3dfdb4629ffd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a208863ad493da732d40e3dfdb4629ffd">operator=</a> (int v)</td></tr>
<tr class="memdesc:a208863ad493da732d40e3dfdb4629ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set current value node underlying data to.  <a href="#a208863ad493da732d40e3dfdb4629ffd">More...</a><br /></td></tr>
<tr class="separator:a208863ad493da732d40e3dfdb4629ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4465d1e9f71fb211dcf01a423b1e99b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a4465d1e9f71fb211dcf01a423b1e99b5">operator=</a> (int64_t v)</td></tr>
<tr class="memdesc:a4465d1e9f71fb211dcf01a423b1e99b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set current value node underlying data to.  <a href="#a4465d1e9f71fb211dcf01a423b1e99b5">More...</a><br /></td></tr>
<tr class="separator:a4465d1e9f71fb211dcf01a423b1e99b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746f060ae4875cb6dfbe109e7332eade"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a746f060ae4875cb6dfbe109e7332eade">operator=</a> (double v)</td></tr>
<tr class="memdesc:a746f060ae4875cb6dfbe109e7332eade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set current value node underlying data to.  <a href="#a746f060ae4875cb6dfbe109e7332eade">More...</a><br /></td></tr>
<tr class="separator:a746f060ae4875cb6dfbe109e7332eade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6497873c16da02540e7748bac2f216b5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a6497873c16da02540e7748bac2f216b5">operator=</a> (bool v)</td></tr>
<tr class="memdesc:a6497873c16da02540e7748bac2f216b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set current value node underlying data to.  <a href="#a6497873c16da02540e7748bac2f216b5">More...</a><br /></td></tr>
<tr class="separator:a6497873c16da02540e7748bac2f216b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac665711351af14dfd5a5c19a04336561"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#ac665711351af14dfd5a5c19a04336561">operator=</a> (const std::string &amp;v)</td></tr>
<tr class="memdesc:ac665711351af14dfd5a5c19a04336561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set current value node underlying data to.  <a href="#ac665711351af14dfd5a5c19a04336561">More...</a><br /></td></tr>
<tr class="separator:ac665711351af14dfd5a5c19a04336561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c80347b1b774e867f7b20b94977f0a6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a7c80347b1b774e867f7b20b94977f0a6">operator=</a> (const char *v)</td></tr>
<tr class="memdesc:a7c80347b1b774e867f7b20b94977f0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set current value node underlying data to.  <a href="#a7c80347b1b774e867f7b20b94977f0a6">More...</a><br /></td></tr>
<tr class="separator:a7c80347b1b774e867f7b20b94977f0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b3b57903275f94b43873a0ec938aa8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a41b3b57903275f94b43873a0ec938aa8">put</a> (const std::string &amp;key, int v)</td></tr>
<tr class="memdesc:a41b3b57903275f94b43873a0ec938aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add key-value to object node.  <a href="#a41b3b57903275f94b43873a0ec938aa8">More...</a><br /></td></tr>
<tr class="separator:a41b3b57903275f94b43873a0ec938aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d1bd1ce14fddf5b445d499ad0549f3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#af3d1bd1ce14fddf5b445d499ad0549f3">put</a> (const std::string &amp;key, int64_t v)</td></tr>
<tr class="memdesc:af3d1bd1ce14fddf5b445d499ad0549f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add key-value to object node.  <a href="#af3d1bd1ce14fddf5b445d499ad0549f3">More...</a><br /></td></tr>
<tr class="separator:af3d1bd1ce14fddf5b445d499ad0549f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f28e7e21d7dff2d6b420bb212217d3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a84f28e7e21d7dff2d6b420bb212217d3">put</a> (const std::string &amp;key, double v)</td></tr>
<tr class="memdesc:a84f28e7e21d7dff2d6b420bb212217d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add key-value to object node.  <a href="#a84f28e7e21d7dff2d6b420bb212217d3">More...</a><br /></td></tr>
<tr class="separator:a84f28e7e21d7dff2d6b420bb212217d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012325a22f6b30e7bfeb3bcb352bb462"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a012325a22f6b30e7bfeb3bcb352bb462">put</a> (const std::string &amp;key, bool v)</td></tr>
<tr class="memdesc:a012325a22f6b30e7bfeb3bcb352bb462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add key-value to object node.  <a href="#a012325a22f6b30e7bfeb3bcb352bb462">More...</a><br /></td></tr>
<tr class="separator:a012325a22f6b30e7bfeb3bcb352bb462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbb196dd3ab32f588e8f2921d2070df"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#afcbb196dd3ab32f588e8f2921d2070df">put</a> (const std::string &amp;key, const std::string &amp;v)</td></tr>
<tr class="memdesc:afcbb196dd3ab32f588e8f2921d2070df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add key-value to object node.  <a href="#afcbb196dd3ab32f588e8f2921d2070df">More...</a><br /></td></tr>
<tr class="separator:afcbb196dd3ab32f588e8f2921d2070df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c942741177931bd13ace09d709fde18"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a0c942741177931bd13ace09d709fde18">put</a> (const std::string &amp;key, const char *v)</td></tr>
<tr class="memdesc:a0c942741177931bd13ace09d709fde18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add key-value to object node.  <a href="#a0c942741177931bd13ace09d709fde18">More...</a><br /></td></tr>
<tr class="separator:a0c942741177931bd13ace09d709fde18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743f79a05d613f0aed00b690a5b74cdb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a743f79a05d613f0aed00b690a5b74cdb">add</a> (int v)</td></tr>
<tr class="memdesc:a743f79a05d613f0aed00b690a5b74cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add int to array node.  <a href="#a743f79a05d613f0aed00b690a5b74cdb">More...</a><br /></td></tr>
<tr class="separator:a743f79a05d613f0aed00b690a5b74cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c1366c6fd248ff565acd3e4fb2388c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a30c1366c6fd248ff565acd3e4fb2388c">add</a> (int64_t v)</td></tr>
<tr class="memdesc:a30c1366c6fd248ff565acd3e4fb2388c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add long to array node.  <a href="#a30c1366c6fd248ff565acd3e4fb2388c">More...</a><br /></td></tr>
<tr class="separator:a30c1366c6fd248ff565acd3e4fb2388c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5b8841fb2770a516d66e49ee546c6e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a4e5b8841fb2770a516d66e49ee546c6e">add</a> (double v)</td></tr>
<tr class="memdesc:a4e5b8841fb2770a516d66e49ee546c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add double to array node.  <a href="#a4e5b8841fb2770a516d66e49ee546c6e">More...</a><br /></td></tr>
<tr class="separator:a4e5b8841fb2770a516d66e49ee546c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20093d7b9463332b3b58ca2eda81813"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#ad20093d7b9463332b3b58ca2eda81813">add</a> (bool v)</td></tr>
<tr class="memdesc:ad20093d7b9463332b3b58ca2eda81813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add bool to array node.  <a href="#ad20093d7b9463332b3b58ca2eda81813">More...</a><br /></td></tr>
<tr class="separator:ad20093d7b9463332b3b58ca2eda81813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc44c9d9a68f6d9f174004b1f742ddd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#abcc44c9d9a68f6d9f174004b1f742ddd">add</a> (const std::string &amp;v)</td></tr>
<tr class="memdesc:abcc44c9d9a68f6d9f174004b1f742ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add string to array node.  <a href="#abcc44c9d9a68f6d9f174004b1f742ddd">More...</a><br /></td></tr>
<tr class="separator:abcc44c9d9a68f6d9f174004b1f742ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e75f193c00ac26b178dc1863927742b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a0e75f193c00ac26b178dc1863927742b">add</a> (const char *v)</td></tr>
<tr class="memdesc:a0e75f193c00ac26b178dc1863927742b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add C string to array node.  <a href="#a0e75f193c00ac26b178dc1863927742b">More...</a><br /></td></tr>
<tr class="separator:a0e75f193c00ac26b178dc1863927742b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1798ef2803159f9274444dfe20e0ec"><td class="memTemplParams" colspan="2">template&lt;typename forw_it &gt; </td></tr>
<tr class="memitem:a1d1798ef2803159f9274444dfe20e0ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classesft_1_1stor_1_1node.html">node</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a1d1798ef2803159f9274444dfe20e0ec">add</a> (forw_it <a class="el" href="classesft_1_1stor_1_1node.html#acf6a4f25921753fbb86284eca75cce29">begin</a>, forw_it <a class="el" href="classesft_1_1stor_1_1node.html#a8fb8fd2274e46c534f07a53ae0783086">end</a>)</td></tr>
<tr class="memdesc:a1d1798ef2803159f9274444dfe20e0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all items dereferenced from forward_iterator forw_it to array node.  <a href="#a1d1798ef2803159f9274444dfe20e0ec">More...</a><br /></td></tr>
<tr class="separator:a1d1798ef2803159f9274444dfe20e0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1643e9e5952223dfc681b762f5f48e"><td class="memTemplParams" colspan="2">template&lt;typename item &gt; </td></tr>
<tr class="memitem:a9f1643e9e5952223dfc681b762f5f48e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classesft_1_1stor_1_1node.html">node</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a9f1643e9e5952223dfc681b762f5f48e">add</a> (const std::vector&lt; item &gt; &amp;v)</td></tr>
<tr class="memdesc:a9f1643e9e5952223dfc681b762f5f48e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all items from the vector <code>v</code> to array node.  <a href="#a9f1643e9e5952223dfc681b762f5f48e">More...</a><br /></td></tr>
<tr class="separator:a9f1643e9e5952223dfc681b762f5f48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416ff3748cc1b7616e25a253a8e93fab"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a416ff3748cc1b7616e25a253a8e93fab">add_array</a> ()</td></tr>
<tr class="memdesc:a416ff3748cc1b7616e25a253a8e93fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add array to array node.  <a href="#a416ff3748cc1b7616e25a253a8e93fab">More...</a><br /></td></tr>
<tr class="separator:a416ff3748cc1b7616e25a253a8e93fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24e21a3b08deb1f3cb45ac8f874dec3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#ad24e21a3b08deb1f3cb45ac8f874dec3">add_object</a> ()</td></tr>
<tr class="memdesc:ad24e21a3b08deb1f3cb45ac8f874dec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add object to array node.  <a href="#ad24e21a3b08deb1f3cb45ac8f874dec3">More...</a><br /></td></tr>
<tr class="separator:ad24e21a3b08deb1f3cb45ac8f874dec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016e3deaf938b3b0d309fb6752e8198f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a016e3deaf938b3b0d309fb6752e8198f">has</a> (const std::string &amp;key) const</td></tr>
<tr class="memdesc:a016e3deaf938b3b0d309fb6752e8198f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a member exists under.  <a href="#a016e3deaf938b3b0d309fb6752e8198f">More...</a><br /></td></tr>
<tr class="separator:a016e3deaf938b3b0d309fb6752e8198f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d0f4b19d3d6f07c1168d4dcf360b44"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#ac8d0f4b19d3d6f07c1168d4dcf360b44">operator[]</a> (const std::string &amp;key) const</td></tr>
<tr class="memdesc:ac8d0f4b19d3d6f07c1168d4dcf360b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to return node with key 'key'.  <a href="#ac8d0f4b19d3d6f07c1168d4dcf360b44">More...</a><br /></td></tr>
<tr class="separator:ac8d0f4b19d3d6f07c1168d4dcf360b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97554d63bcef57c7ce5203967fa39f9f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a97554d63bcef57c7ce5203967fa39f9f">operator[]</a> (std::size_t indx) const</td></tr>
<tr class="memdesc:a97554d63bcef57c7ce5203967fa39f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to return node at index.  <a href="#a97554d63bcef57c7ce5203967fa39f9f">More...</a><br /></td></tr>
<tr class="separator:a97554d63bcef57c7ce5203967fa39f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710222cefbe8f580f2af915522854263"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a710222cefbe8f580f2af915522854263">size</a> () const</td></tr>
<tr class="memdesc:a710222cefbe8f580f2af915522854263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of children for this node.  <a href="#a710222cefbe8f580f2af915522854263">More...</a><br /></td></tr>
<tr class="separator:a710222cefbe8f580f2af915522854263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9a8d226e7eb10734b77622f24ef36c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a1f9a8d226e7eb10734b77622f24ef36c">empty</a> () const</td></tr>
<tr class="memdesc:a1f9a8d226e7eb10734b77622f24ef36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <a class="el" href="classesft_1_1stor_1_1node.html#a710222cefbe8f580f2af915522854263" title="Return number of children for this node. ">size()</a> == 0.  <a href="#a1f9a8d226e7eb10734b77622f24ef36c">More...</a><br /></td></tr>
<tr class="separator:a1f9a8d226e7eb10734b77622f24ef36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5163c559756d0ec98aed18a933a30f8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#aa5163c559756d0ec98aed18a933a30f8">remove</a> (const std::string &amp;key)</td></tr>
<tr class="memdesc:aa5163c559756d0ec98aed18a933a30f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the child node at key <code>key</code>.  <a href="#aa5163c559756d0ec98aed18a933a30f8">More...</a><br /></td></tr>
<tr class="separator:aa5163c559756d0ec98aed18a933a30f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85fcbc2b1b2bcfff9cc010372220df4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classesft_1_1stor_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a85fcbc2b1b2bcfff9cc010372220df4f">remove</a> (<a class="el" href="classesft_1_1stor_1_1const__iterator.html">const_iterator</a> it)</td></tr>
<tr class="memdesc:a85fcbc2b1b2bcfff9cc010372220df4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes the member iterator <code>it</code> points to and returns the iterator to item coming after the one deleted. If <code>it</code> is equal to <a class="el" href="classesft_1_1stor_1_1node.html#a03a6a880bea8da6227d91de28d618838" title="return const_iterator to one after the last child of this node ">cend()</a>, the behaviour is undefined.  <a href="#a85fcbc2b1b2bcfff9cc010372220df4f">More...</a><br /></td></tr>
<tr class="separator:a85fcbc2b1b2bcfff9cc010372220df4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a757eff90b7a537dc1af43e021dd1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classesft_1_1stor_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#ae4a757eff90b7a537dc1af43e021dd1f">remove</a> (<a class="el" href="classesft_1_1stor_1_1const__iterator.html">const_iterator</a> first, <a class="el" href="classesft_1_1stor_1_1const__iterator.html">const_iterator</a> last)</td></tr>
<tr class="memdesc:ae4a757eff90b7a537dc1af43e021dd1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes the members in the range [first, last) and returns the item coming after the one deleted.  <a href="#ae4a757eff90b7a537dc1af43e021dd1f">More...</a><br /></td></tr>
<tr class="separator:ae4a757eff90b7a537dc1af43e021dd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c75883bd7353856cff11122a090eae1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a7c75883bd7353856cff11122a090eae1">remove_all</a> () const</td></tr>
<tr class="memdesc:a7c75883bd7353856cff11122a090eae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all the children of this node.  <a href="#a7c75883bd7353856cff11122a090eae1">More...</a><br /></td></tr>
<tr class="separator:a7c75883bd7353856cff11122a090eae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc7970e564552457baecc5cf72dafbd"><td class="memItemLeft" align="right" valign="top"><a id="adfc7970e564552457baecc5cf72dafbd"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#adfc7970e564552457baecc5cf72dafbd">json</a> () const</td></tr>
<tr class="memdesc:adfc7970e564552457baecc5cf72dafbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return string JSON represeantation of the this node and descendants. <br /></td></tr>
<tr class="separator:adfc7970e564552457baecc5cf72dafbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb988cfd5776a4a53faac8edd59e4c8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a6cb988cfd5776a4a53faac8edd59e4c8">json</a> (const std::string &amp;jsn)</td></tr>
<tr class="memdesc:a6cb988cfd5776a4a53faac8edd59e4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">replaces this node with the node resulting from parsing <code>json</code>  <a href="#a6cb988cfd5776a4a53faac8edd59e4c8">More...</a><br /></td></tr>
<tr class="separator:a6cb988cfd5776a4a53faac8edd59e4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082849c900e6ea972c39f29cebfcd6ba"><td class="memItemLeft" align="right" valign="top"><a id="a082849c900e6ea972c39f29cebfcd6ba"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a082849c900e6ea972c39f29cebfcd6ba">copy</a> (const <a class="el" href="classesft_1_1stor_1_1node.html">node</a> &amp;v)</td></tr>
<tr class="memdesc:a082849c900e6ea972c39f29cebfcd6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">deep copies the node <code>v</code> onto this node. <br /></td></tr>
<tr class="separator:a082849c900e6ea972c39f29cebfcd6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982a06dec65f0298884a7e00f1b54b10"><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a982a06dec65f0298884a7e00f1b54b10">write_to_stream</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:a982a06dec65f0298884a7e00f1b54b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write this node and descendants into std::ostream.  <a href="#a982a06dec65f0298884a7e00f1b54b10">More...</a><br /></td></tr>
<tr class="separator:a982a06dec65f0298884a7e00f1b54b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6a4f25921753fbb86284eca75cce29"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classesft_1_1stor_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#acf6a4f25921753fbb86284eca75cce29">begin</a> ()</td></tr>
<tr class="memdesc:acf6a4f25921753fbb86284eca75cce29"><td class="mdescLeft">&#160;</td><td class="mdescRight">return iterator to first child of this node  <a href="#acf6a4f25921753fbb86284eca75cce29">More...</a><br /></td></tr>
<tr class="separator:acf6a4f25921753fbb86284eca75cce29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb8fd2274e46c534f07a53ae0783086"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classesft_1_1stor_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a8fb8fd2274e46c534f07a53ae0783086">end</a> ()</td></tr>
<tr class="memdesc:a8fb8fd2274e46c534f07a53ae0783086"><td class="mdescLeft">&#160;</td><td class="mdescRight">return iterator to one after the last child of this node  <a href="#a8fb8fd2274e46c534f07a53ae0783086">More...</a><br /></td></tr>
<tr class="separator:a8fb8fd2274e46c534f07a53ae0783086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b56c9101b1ae4365bd2c4bd1467872c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classesft_1_1stor_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a1b56c9101b1ae4365bd2c4bd1467872c">cbegin</a> () const</td></tr>
<tr class="memdesc:a1b56c9101b1ae4365bd2c4bd1467872c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return <a class="el" href="classesft_1_1stor_1_1const__iterator.html" title="const_iterator allows to iterate over read-only nodes ">const_iterator</a> to first child of this node  <a href="#a1b56c9101b1ae4365bd2c4bd1467872c">More...</a><br /></td></tr>
<tr class="separator:a1b56c9101b1ae4365bd2c4bd1467872c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a6a880bea8da6227d91de28d618838"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classesft_1_1stor_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a03a6a880bea8da6227d91de28d618838">cend</a> () const</td></tr>
<tr class="memdesc:a03a6a880bea8da6227d91de28d618838"><td class="mdescLeft">&#160;</td><td class="mdescRight">return <a class="el" href="classesft_1_1stor_1_1const__iterator.html" title="const_iterator allows to iterate over read-only nodes ">const_iterator</a> to one after the last child of this node  <a href="#a03a6a880bea8da6227d91de28d618838">More...</a><br /></td></tr>
<tr class="separator:a03a6a880bea8da6227d91de28d618838"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a355255580b76f839e4fd954ceac5bfb3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a355255580b76f839e4fd954ceac5bfb3">node</a> (rapidjson::Value *value, rapidjson::Document *doc)</td></tr>
<tr class="memdesc:a355255580b76f839e4fd954ceac5bfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a355255580b76f839e4fd954ceac5bfb3">More...</a><br /></td></tr>
<tr class="separator:a355255580b76f839e4fd954ceac5bfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bca71c63a35fd8457a264bf4b25070"><td class="memItemLeft" align="right" valign="top"><a id="af9bca71c63a35fd8457a264bf4b25070"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#af9bca71c63a35fd8457a264bf4b25070">node</a> ()</td></tr>
<tr class="memdesc:af9bca71c63a35fd8457a264bf4b25070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:af9bca71c63a35fd8457a264bf4b25070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9ad70c995740da1adb79488335ce5d"><td class="memItemLeft" align="right" valign="top"><a id="a3c9ad70c995740da1adb79488335ce5d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a3c9ad70c995740da1adb79488335ce5d">set_underlying</a> (rapidjson::Value *underlying)</td></tr>
<tr class="memdesc:a3c9ad70c995740da1adb79488335ce5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject underlying data pointer into node. <br /></td></tr>
<tr class="separator:a3c9ad70c995740da1adb79488335ce5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9004542deeccba37faabf03ed1c7f9"><td class="memItemLeft" align="right" valign="top"><a id="a8c9004542deeccba37faabf03ed1c7f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classesft_1_1stor_1_1node.html#a8c9004542deeccba37faabf03ed1c7f9">set_document</a> (rapidjson::Document *doc)</td></tr>
<tr class="memdesc:a8c9004542deeccba37faabf03ed1c7f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject rapidjson::Document pointer into node. <br /></td></tr>
<tr class="separator:a8c9004542deeccba37faabf03ed1c7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a67171474c4da6cc8efe0c7fafefd2b2d"><td class="memItemLeft" align="right" valign="top"><a id="a67171474c4da6cc8efe0c7fafefd2b2d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a67171474c4da6cc8efe0c7fafefd2b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac220ce1c155db1ac44146c12d178056f"><td class="memItemLeft" align="right" valign="top"><a id="ac220ce1c155db1ac44146c12d178056f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:ac220ce1c155db1ac44146c12d178056f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>node represents an interface to a specific element in the underlying JSON data tree. </p>
<p>node is a thin wrapper of an underlying JSON data node, only made of weak pointers to such data and exposes the functions used to create or alter JSON data. For this reason, nodes can cheaply be returned by value. ATTENTION: Because the owner of the underlying JSON tree is <a class="el" href="classesft_1_1stor_1_1document.html" title="Document is a Node that represnts the root of the node&#39;s tree. ">esft::stor::document</a>, a single node existence depends on the existence of document. For this reason, a node instance must not be used after its document owner has ceased to exist.</p>
<p>Some functions are only usable if the underlying data is either of type value, object or array, or a combination of them. If a certain functionality is invoked on the wrong node, a <a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a> is thrown. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a438cf98554f0e666dc9d161dbf4f9a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438cf98554f0e666dc9d161dbf4f9a4f">&#9670;&nbsp;</a></span>node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esft::stor::node::node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classesft_1_1stor_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shallow Copy constructor. </p>
<p>For deep copy, use <a class="el" href="classesft_1_1stor_1_1node.html#adfc7970e564552457baecc5cf72dafbd" title="Return string JSON represeantation of the this node and descendants. ">json()</a>(string) serialization/deserialziation mechanism or copy(node&amp;) </p>

</div>
</div>
<a id="a355255580b76f839e4fd954ceac5bfb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a355255580b76f839e4fd954ceac5bfb3">&#9670;&nbsp;</a></span>node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">esft::stor::node::node </td>
          <td>(</td>
          <td class="paramtype">rapidjson::Value *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rapidjson::Document *&#160;</td>
          <td class="paramname"><em>doc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>pointer to underlying data </td></tr>
    <tr><td class="paramname">doc</td><td>pointer to document (node tree owner) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a743f79a05d613f0aed00b690a5b74cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743f79a05d613f0aed00b690a5b74cdb">&#9670;&nbsp;</a></span>add() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a>&amp; esft::stor::node::add </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add int to array node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>int value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this node </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30c1366c6fd248ff565acd3e4fb2388c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c1366c6fd248ff565acd3e4fb2388c">&#9670;&nbsp;</a></span>add() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a>&amp; esft::stor::node::add </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add long to array node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>long value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this node </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e5b8841fb2770a516d66e49ee546c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5b8841fb2770a516d66e49ee546c6e">&#9670;&nbsp;</a></span>add() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a>&amp; esft::stor::node::add </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add double to array node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>double value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this node </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad20093d7b9463332b3b58ca2eda81813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad20093d7b9463332b3b58ca2eda81813">&#9670;&nbsp;</a></span>add() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a>&amp; esft::stor::node::add </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add bool to array node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>bool value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this node </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abcc44c9d9a68f6d9f174004b1f742ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc44c9d9a68f6d9f174004b1f742ddd">&#9670;&nbsp;</a></span>add() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a>&amp; esft::stor::node::add </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add string to array node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>string value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this node </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e75f193c00ac26b178dc1863927742b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e75f193c00ac26b178dc1863927742b">&#9670;&nbsp;</a></span>add() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a>&amp; esft::stor::node::add </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add C string to array node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>C string value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this node </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d1798ef2803159f9274444dfe20e0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1798ef2803159f9274444dfe20e0ec">&#9670;&nbsp;</a></span>add() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename forw_it &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classesft_1_1stor_1_1node.html">node</a> &amp; esft::stor::node::add </td>
          <td>(</td>
          <td class="paramtype">forw_it&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">forw_it&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add all items dereferenced from forward_iterator forw_it to array node. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">forw_it</td><td>forward iterator to items of an array node </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to beginning of range </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing to one after end of range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this node </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f1643e9e5952223dfc681b762f5f48e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1643e9e5952223dfc681b762f5f48e">&#9670;&nbsp;</a></span>add() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename item &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classesft_1_1stor_1_1node.html">node</a> &amp; esft::stor::node::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; item &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add all items from the vector <code>v</code> to array node. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">item</td><td>item of an array node </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vector of items</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this node </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a416ff3748cc1b7616e25a253a8e93fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416ff3748cc1b7616e25a253a8e93fab">&#9670;&nbsp;</a></span>add_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a> esft::stor::node::add_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add array to array node. </p>
<dl class="section return"><dt>Returns</dt><dd>created array </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad24e21a3b08deb1f3cb45ac8f874dec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24e21a3b08deb1f3cb45ac8f874dec3">&#9670;&nbsp;</a></span>add_object()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a> esft::stor::node::add_object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add object to array node. </p>
<dl class="section return"><dt>Returns</dt><dd>created object </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab68336ff0acdeb2b1aad7c14ca4c1171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68336ff0acdeb2b1aad7c14ca4c1171">&#9670;&nbsp;</a></span>as_bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool esft::stor::node::as_bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to return the underlying data as Boolean. </p>
<p>This function may only be called on a value node, which is a node that is not an object node nor an array node. In JSON terms, it can only be used for leaf elements. ie: node = "true" -&gt; ok node = {"a":"true"} -&gt; not ok</p>
<dl class="section return"><dt>Returns</dt><dd>data as Boolean </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30e0b75292eb7e044277d0df69801e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e0b75292eb7e044277d0df69801e9f">&#9670;&nbsp;</a></span>as_cstring()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt;const char *, std::size_t&gt; esft::stor::node::as_cstring </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to return the underlying data as a C string paired with its actual length. </p>
<p>The actual length refers to the entire string, which may be exceed the first \0 character encountered. Having this length returned is necessary, as JSON can contain \0 (escaped as , different from \0 required by C), according to RFC 4627. If you know that the returned string will be a normal C string, then just invoke esft_stor_node_as_string</p>
<p>This function may only be called on a value node, which is a node that is not an object node nor an array node. In JSON terms, it can only be used for leaf elements. ie: node = "hello" -&gt; ok node = {"a":"hello"} -&gt; not ok</p>
<dl class="section return"><dt>Returns</dt><dd>data as C String with its length </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42d18ca9a9123367d5f602c82d11e24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d18ca9a9123367d5f602c82d11e24c">&#9670;&nbsp;</a></span>as_double()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double esft::stor::node::as_double </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to return the underlying data as Double. </p>
<p>This function may only be called on a value node, which is a node that is not an object node nor an array node. In JSON terms, it can only be used for leaf elements. ie: node = "1.0" -&gt; ok node = {"a":1.0} -&gt; not ok</p>
<dl class="section return"><dt>Returns</dt><dd>data as Double </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56d772245bf170ac691daf82dcbe34e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d772245bf170ac691daf82dcbe34e1">&#9670;&nbsp;</a></span>as_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int esft::stor::node::as_int </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to return the underlying data as Integer. </p>
<p>This function may only be called on a value node, which is a node that is not an object node nor an array node. In JSON terms, it can only be used for leaf elements. ie: node = "1" -&gt; ok node = {"a":1} -&gt; not ok</p>
<dl class="section return"><dt>Returns</dt><dd>data as Integer </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e1c34d6c6f449b57600c9ddbacd0622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e1c34d6c6f449b57600c9ddbacd0622">&#9670;&nbsp;</a></span>as_long()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t esft::stor::node::as_long </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to return the underlying data as Long. </p>
<p>This function may only be called on a value node, which is a node that is not an object node nor an array node. In JSON terms, it can only be used for leaf elements. ie: node = "1" -&gt; ok node = {"a":1} -&gt; not ok</p>
<dl class="section return"><dt>Returns</dt><dd>data as Long </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a275c4efee89c3b60e7665440e9efe52b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a275c4efee89c3b60e7665440e9efe52b">&#9670;&nbsp;</a></span>as_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string esft::stor::node::as_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to return the underlying data as a string. </p>
<p>This function may only be called on a value node, which is a node that is not an object node nor an array node. In JSON terms, it can only be used for leaf elements. ie: node = "hello" -&gt; ok node = {"a":"hello"} -&gt; not ok</p>
<dl class="section return"><dt>Returns</dt><dd>data as C++ String </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf6a4f25921753fbb86284eca75cce29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6a4f25921753fbb86284eca75cce29">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classesft_1_1stor_1_1iterator.html">iterator</a> esft::stor::node::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return iterator to first child of this node </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b56c9101b1ae4365bd2c4bd1467872c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b56c9101b1ae4365bd2c4bd1467872c">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classesft_1_1stor_1_1const__iterator.html">const_iterator</a> esft::stor::node::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return <a class="el" href="classesft_1_1stor_1_1const__iterator.html" title="const_iterator allows to iterate over read-only nodes ">const_iterator</a> to first child of this node </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03a6a880bea8da6227d91de28d618838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a6a880bea8da6227d91de28d618838">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classesft_1_1stor_1_1const__iterator.html">const_iterator</a> esft::stor::node::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return <a class="el" href="classesft_1_1stor_1_1const__iterator.html" title="const_iterator allows to iterate over read-only nodes ">const_iterator</a> to one after the last child of this node </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f9a8d226e7eb10734b77622f24ef36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9a8d226e7eb10734b77622f24ef36c">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool esft::stor::node::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if <a class="el" href="classesft_1_1stor_1_1node.html#a710222cefbe8f580f2af915522854263" title="Return number of children for this node. ">size()</a> == 0. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fb8fd2274e46c534f07a53ae0783086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb8fd2274e46c534f07a53ae0783086">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classesft_1_1stor_1_1iterator.html">iterator</a> esft::stor::node::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return iterator to one after the last child of this node </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a016e3deaf938b3b0d309fb6752e8198f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a016e3deaf938b3b0d309fb6752e8198f">&#9670;&nbsp;</a></span>has()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool esft::stor::node::has </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a member exists under. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>This function can only be used from an object node</td></tr>
    <tr><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if member exists, False otherwise </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if called on a non object node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf0255e81d5c5062cfb59b39f3850ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf0255e81d5c5062cfb59b39f3850ff5">&#9670;&nbsp;</a></span>is_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool esft::stor::node::is_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether underlying data is an Array. </p>
<p>An Array is intended in the JSON sense of Array.</p>
<dl class="section return"><dt>Returns</dt><dd>True if Array, else False. </dd></dl>

</div>
</div>
<a id="a27119b0e30639a436f51efafbbfdf293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27119b0e30639a436f51efafbbfdf293">&#9670;&nbsp;</a></span>is_bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool esft::stor::node::is_bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether underlying data is a Boolean. </p>
<dl class="section return"><dt>Returns</dt><dd>True if Boolean, else False. </dd></dl>

</div>
</div>
<a id="a24be3f8c6ba5c5f998366ecc2eca25a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24be3f8c6ba5c5f998366ecc2eca25a6">&#9670;&nbsp;</a></span>is_double()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool esft::stor::node::is_double </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether underlying data is a Double. </p>
<dl class="section return"><dt>Returns</dt><dd>True if Double, else False. </dd></dl>

</div>
</div>
<a id="ad6f9e757796834aea042a285ad8cc403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f9e757796834aea042a285ad8cc403">&#9670;&nbsp;</a></span>is_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool esft::stor::node::is_int </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether underlying data is a Integer. </p>
<dl class="section return"><dt>Returns</dt><dd>True if Integer, else False. </dd></dl>

</div>
</div>
<a id="ade8c9e74cf4eca77c747e03ac9a0714d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade8c9e74cf4eca77c747e03ac9a0714d">&#9670;&nbsp;</a></span>is_long()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool esft::stor::node::is_long </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether underlying data is a Long. </p>
<dl class="section return"><dt>Returns</dt><dd>True if Long, else False. </dd></dl>

</div>
</div>
<a id="afe91d9d1f0fee459a05ddb3296cd1eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe91d9d1f0fee459a05ddb3296cd1eb8">&#9670;&nbsp;</a></span>is_null()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool esft::stor::node::is_null </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether underlying data is Null. </p>
<p>An Null is intended in the JSON sense of Null, as in Empty. ie: {}, []</p>
<dl class="section return"><dt>Returns</dt><dd>True if Object, else False. </dd></dl>

</div>
</div>
<a id="a536b1db2509af69b76b02f9ea3fba20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536b1db2509af69b76b02f9ea3fba20f">&#9670;&nbsp;</a></span>is_num()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool esft::stor::node::is_num </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether underlying data is a Number. </p>
<p>Underlying data is a Number if it's either an:</p><ul>
<li>int</li>
<li>long</li>
<li>double <dl class="section return"><dt>Returns</dt><dd>True if Number, else False. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a9542d872fcdc42b454a550625f6c9316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9542d872fcdc42b454a550625f6c9316">&#9670;&nbsp;</a></span>is_object()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool esft::stor::node::is_object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether underlying data is an Object. </p>
<p>An Object is intended in the JSON sense of Object.</p>
<dl class="section return"><dt>Returns</dt><dd>True if Object, else False. </dd></dl>

</div>
</div>
<a id="ac1c1d002e2042fd0bf984d34a3069a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c1d002e2042fd0bf984d34a3069a5d">&#9670;&nbsp;</a></span>is_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool esft::stor::node::is_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether underlying data is a String. </p>
<dl class="section return"><dt>Returns</dt><dd>True if String, else False. </dd></dl>

</div>
</div>
<a id="a6cb988cfd5776a4a53faac8edd59e4c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb988cfd5776a4a53faac8edd59e4c8">&#9670;&nbsp;</a></span>json()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void esft::stor::node::json </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>jsn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>replaces this node with the node resulting from parsing <code>json</code> </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7868f607e839511f8520dce6c2727773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7868f607e839511f8520dce6c2727773">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classesft_1_1stor_1_1node.html">node</a>&amp; esft::stor::node::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classesft_1_1stor_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shallow Copy assignment. </p>
<p>For deep copy, use <a class="el" href="classesft_1_1stor_1_1node.html#adfc7970e564552457baecc5cf72dafbd" title="Return string JSON represeantation of the this node and descendants. ">json()</a>(string) serialization/deserialziation mechanism or copy(node&amp;) </p>

</div>
</div>
<a id="a208863ad493da732d40e3dfdb4629ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208863ad493da732d40e3dfdb4629ffd">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void esft::stor::node::operator= </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set current value node underlying data to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td></td></tr>
    <tr><td class="paramname">v</td><td>Integer to assign as new value to underlying data </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4465d1e9f71fb211dcf01a423b1e99b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4465d1e9f71fb211dcf01a423b1e99b5">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esft::stor::node::operator= </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set current value node underlying data to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td></td></tr>
    <tr><td class="paramname">v</td><td>Long to assign as new value to underlying data </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a746f060ae4875cb6dfbe109e7332eade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746f060ae4875cb6dfbe109e7332eade">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void esft::stor::node::operator= </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set current value node underlying data to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td></td></tr>
    <tr><td class="paramname">v</td><td>Double to assign as new value to underlying data </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6497873c16da02540e7748bac2f216b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6497873c16da02540e7748bac2f216b5">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void esft::stor::node::operator= </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set current value node underlying data to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td></td></tr>
    <tr><td class="paramname">v</td><td>Bool to assign as new value to underlying data </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac665711351af14dfd5a5c19a04336561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac665711351af14dfd5a5c19a04336561">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void esft::stor::node::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set current value node underlying data to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td></td></tr>
    <tr><td class="paramname">v</td><td>String to assign as new value to underlying data </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c80347b1b774e867f7b20b94977f0a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c80347b1b774e867f7b20b94977f0a6">&#9670;&nbsp;</a></span>operator=() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void esft::stor::node::operator= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set current value node underlying data to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td></td></tr>
    <tr><td class="paramname">v</td><td>C string to assign as new value to underlying data </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8d0f4b19d3d6f07c1168d4dcf360b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d0f4b19d3d6f07c1168d4dcf360b44">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a> esft::stor::node::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to return node with key 'key'. </p>
<p>This function can only be used on an object node</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>node with key 'key' </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97554d63bcef57c7ce5203967fa39f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97554d63bcef57c7ce5203967fa39f9f">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a> esft::stor::node::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>indx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to return node at index. </p>
<p>This function can only be used on an object node</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>node with key 'key' </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41b3b57903275f94b43873a0ec938aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b3b57903275f94b43873a0ec938aa8">&#9670;&nbsp;</a></span>put() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a>&amp; esft::stor::node::put </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add key-value to object node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>key </td></tr>
    <tr><td class="paramname">v</td><td>int to assign to key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this node </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3d1bd1ce14fddf5b445d499ad0549f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d1bd1ce14fddf5b445d499ad0549f3">&#9670;&nbsp;</a></span>put() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a>&amp; esft::stor::node::put </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add key-value to object node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>key </td></tr>
    <tr><td class="paramname">v</td><td>long to assign to key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this node </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84f28e7e21d7dff2d6b420bb212217d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f28e7e21d7dff2d6b420bb212217d3">&#9670;&nbsp;</a></span>put() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a>&amp; esft::stor::node::put </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add key-value to object node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>key </td></tr>
    <tr><td class="paramname">v</td><td>double to assign to key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this node </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a012325a22f6b30e7bfeb3bcb352bb462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012325a22f6b30e7bfeb3bcb352bb462">&#9670;&nbsp;</a></span>put() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a>&amp; esft::stor::node::put </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add key-value to object node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>key </td></tr>
    <tr><td class="paramname">v</td><td>bool to assign to key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this node </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afcbb196dd3ab32f588e8f2921d2070df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcbb196dd3ab32f588e8f2921d2070df">&#9670;&nbsp;</a></span>put() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a>&amp; esft::stor::node::put </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add key-value to object node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>key </td></tr>
    <tr><td class="paramname">v</td><td>string to assign to key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this node </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c942741177931bd13ace09d709fde18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c942741177931bd13ace09d709fde18">&#9670;&nbsp;</a></span>put() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a>&amp; esft::stor::node::put </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add key-value to object node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>key </td></tr>
    <tr><td class="paramname">v</td><td>C string to assign to key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this node </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5163c559756d0ec98aed18a933a30f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5163c559756d0ec98aed18a933a30f8">&#9670;&nbsp;</a></span>remove() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool esft::stor::node::remove </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the child node at key <code>key</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>If operation succeded, returns true, else false</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85fcbc2b1b2bcfff9cc010372220df4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85fcbc2b1b2bcfff9cc010372220df4f">&#9670;&nbsp;</a></span>remove() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classesft_1_1stor_1_1const__iterator.html">const_iterator</a> esft::stor::node::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classesft_1_1stor_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>removes the member iterator <code>it</code> points to and returns the iterator to item coming after the one deleted. If <code>it</code> is equal to <a class="el" href="classesft_1_1stor_1_1node.html#a03a6a880bea8da6227d91de28d618838" title="return const_iterator to one after the last child of this node ">cend()</a>, the behaviour is undefined. </p>
<dl class="section return"><dt>Returns</dt><dd>next iterator </dd></dl>

</div>
</div>
<a id="ae4a757eff90b7a537dc1af43e021dd1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a757eff90b7a537dc1af43e021dd1f">&#9670;&nbsp;</a></span>remove() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classesft_1_1stor_1_1const__iterator.html">const_iterator</a> esft::stor::node::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classesft_1_1stor_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classesft_1_1stor_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>removes the members in the range [first, last) and returns the item coming after the one deleted. </p>
<dl class="section return"><dt>Returns</dt><dd>next iterator </dd></dl>

</div>
</div>
<a id="a7c75883bd7353856cff11122a090eae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c75883bd7353856cff11122a090eae1">&#9670;&nbsp;</a></span>remove_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void esft::stor::node::remove_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all the children of this node. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a710222cefbe8f580f2af915522854263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710222cefbe8f580f2af915522854263">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t esft::stor::node::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return number of children for this node. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a346697a0fe0f1f8d37b704e406711e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a346697a0fe0f1f8d37b704e406711e8c">&#9670;&nbsp;</a></span>with()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a> esft::stor::node::with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get or create in place object node under key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>This function can only be called on an object node. If object node exists with </td></tr>
    <tr><td class="paramname">key,a</td><td>reference to it is returned. Otherwise, such object is added as a member to the underyling data, with key </td></tr>
    <tr><td class="paramname">key</td><td>ie: node = [1,2,3] -&gt; not ok node = {"a":{"b": 1}} -&gt; ok. with_key("a") returns {"b": 1} node = {"a":1} -&gt; ok. with_key("b") makes {"a":1,"b":{}} and returns {}</td></tr>
    <tr><td class="paramname">key</td><td>parent of object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>object node for key </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14da3cd4ff8ca9fd8d3f393e9ceb3aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14da3cd4ff8ca9fd8d3f393e9ceb3aca">&#9670;&nbsp;</a></span>with_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classesft_1_1stor_1_1node.html">node</a> esft::stor::node::with_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get or create in place array node under key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>This function can only be called on an object node. If array node exists with </td></tr>
    <tr><td class="paramname">key,a</td><td>reference to it is returned. Otherwise, such object is added as a member to the underlying data, with key </td></tr>
    <tr><td class="paramname">key</td><td>ie: node = [1,2,3] -&gt; not ok node = {"a":[1,2,3]} -&gt; ok. with_key("a") returns [1,2,3] node = {"a":1} -&gt; ok. with_key("b") makes {"a":1,"b":[]} and returns []</td></tr>
    <tr><td class="paramname">key</td><td>parent of array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array node for key </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classesft_1_1stor_1_1document__exception.html" title="document_exception is used to signal an error occurred while using document, node, iterator or const_iterator ">document_exception</a></td><td>if node is not of type object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a982a06dec65f0298884a7e00f1b54b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982a06dec65f0298884a7e00f1b54b10">&#9670;&nbsp;</a></span>write_to_stream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::ostream&amp; esft::stor::node::write_to_stream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write this node and descendants into std::ostream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>reference to std::ostream to write into </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/stor/document/<a class="el" href="node_8h_source.html">node.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
